[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 9] = 8;

alias userSP R0;
userSP = SP;

alias parentID R1;
parentID = [SYSTEM_STATUS_TABLE + 1];

alias childID R2;
childID = 0;

[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 13] = SP;

SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1]*16) + 11]*512 - 1;

multipush(R0,R1);
R1 = GET_PCB_ENTRY;
call PROCESS_MANAGER;
childID = R0;
multipop(R0,R1);

if(childID == -1) then 
	[[PAGE_TABLE_BASE + (parentID*20) + 2*((userSP-1)/512)]*512 + ((userSP-1)%512)] = -1;
	[PROCESS_TABLE + (parentID*16) + 9] = 0;
	SP = userSP;
	ireturn;
endif;

alias counter R3;
counter = 0;
//checking and heap allocation if not done before calling fork
while(counter <= 1) do
	if([PAGE_TABLE_BASE + parentID*20 + 4 + 2*counter] == -1) then
		multipush(R0,R1,R2,R3);
		R1 = GET_FREE_PAGE;
		call MEMORY_MANAGER;
		[PAGE_TABLE_BASE + (parentID*20) + 4 + 2*counter] = R0;
		[PAGE_TABLE_BASE + (parentID*20) + 4 + 2*counter + 1] = "1110";
		multipop(R0,R1,R2,R3);
	endif;
	counter = counter + 1;
endwhile;

//getting stack page and user area page for child
counter = 0;
while(counter <= 2) do
	multipush(R0,R1,R2,R3);
	R1 = GET_FREE_PAGE;
	call MEMORY_MANAGER;
	if(counter == 2) then
		[PROCESS_TABLE + childID*16 + 11] = R0;  //user area page number	
	else
		[PAGE_TABLE_BASE + childID*20 + 16 + 2*counter] = R0;
		[PAGE_TABLE_BASE + childID*20 + 16 + 2*counter + 1] = [PAGE_TABLE_BASE + parentID*20 + 16 + 2*counter + 1];
	endif;
	multipop(R0,R1,R2,R3);
	counter = counter + 1;
endwhile;

[PROCESS_TABLE + childID*16 + 3] = [PROCESS_TABLE + parentID*16 + 3]; //user-id
[PROCESS_TABLE + childID*16 + 6] = [PROCESS_TABLE + parentID*16 + 6]; //swap flag
[PROCESS_TABLE + childID*16 + 10] = [PROCESS_TABLE + parentID*16 + 10]; //user area swap status
[PROCESS_TABLE + childID*16 + 7] = [PROCESS_TABLE + parentID*16 + 7]; //inode-index
[PROCESS_TABLE + childID*16 + 13] = [PROCESS_TABLE + parentID*16 + 13];  //uptr

[PROCESS_TABLE + childID*16 + 9] = 0; //mode
[PROCESS_TABLE + childID*16 + 12] = 0;  //kptr
[PROCESS_TABLE + childID*16 + 0] = 0;  //tick
[PROCESS_TABLE + childID*16 + 2] = parentID; //ppid
[PROCESS_TABLE + childID*16 + 4] = CREATED; //state

//per-process disk map table for child
counter = 0;
while(counter <= 9) do
	[DISK_MAP_TABLE + childID*10 + counter] = [DISK_MAP_TABLE + parentID*10 + counter];
	counter = counter + 1;
endwhile;

//page table initialisation of child process
counter = 0;
while(counter <= 7) do
	[PAGE_TABLE_BASE + childID*20 + 2*counter] = [PAGE_TABLE_BASE + parentID*20 + 2*counter];
	[MEMORY_FREE_LIST + [PAGE_TABLE_BASE + childID*20 + 2*counter]] = [MEMORY_FREE_LIST + [PAGE_TABLE_BASE + childID*20 + 2*counter]] + 1;
	[PAGE_TABLE_BASE + childID*20 + 2*counter + 1] = [PAGE_TABLE_BASE + parentID*20 + 2*counter + 1];
	counter = counter + 1;
endwhile;

alias parent_word_address R4;
alias child_word_address R5;
alias word_count R6;
word_count = 0;
counter = 8;
while(counter <= 9) do
	
	parent_word_address = [PAGE_TABLE_BASE + parentID*20 + 2*counter]*512;
	child_word_address = [PAGE_TABLE_BASE + childID*20 + 2*counter]*512;

	while(word_count < 512) do
		[child_word_address + word_count] = [parent_word_address + word_count];
		word_count = word_count + 1;
	endwhile;
	word_count = 0;
	counter = counter + 1;
endwhile;

//Set BP value to top of kernel stack of child
[[PROCESS_TABLE + childID*16 + 11]*512] = BP;
[PROCESS_TABLE + childID*16 + 12] = 1;


//Set return values in user stacks for parent and child
[[PAGE_TABLE_BASE + parentID*20 + 2*((userSP-1)/512)]*512 + ((userSP-1)%512)] = childID;
[[PAGE_TABLE_BASE + childID*20 + 2*(([PROCESS_TABLE + childID*16 + 13]-1)/512)]*512 + (([PROCESS_TABLE + childID*16 + 13]-1)%512)] = 0;

[PROCESS_TABLE + parentID*16 + 9] = 0;
SP = userSP;
ireturn;
